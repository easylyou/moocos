diff -ruP lab3_org/kern/debug/kdebug.c lab3/kern/debug/kdebug.c
--- lab3_org/kern/debug/kdebug.c	2016-04-19 15:56:08.827058000 +0800
+++ lab3/kern/debug/kdebug.c	2016-04-06 13:43:39.119975239 +0800
@@ -305,5 +305,24 @@
       *           NOTICE: the calling funciton's return addr eip  = ss:[ebp+4]
       *                   the calling funciton's ebp = ss:[ebp]
       */
+	uint32_t ebp, eip, i;
+	uint32_t arg1, arg2, arg3, arg4;
+	ebp = read_ebp();
+	eip = read_eip();
+	i = 0; 
+	while(ebp != 0 && i < STACKFRAME_DEPTH)
+	{
+		i ++;
+
+		arg1 = *((uint32_t*)(ebp+8));
+		arg2 = *((uint32_t*)(ebp+12));
+		arg3 = *((uint32_t*)(ebp+16));
+		arg4 = *((uint32_t*)(ebp+20));
+
+		cprintf("ebp: 0x%08x eip: 0x%08x args: 0x%08x 0x%08x 0x%08x 0x%08x\n", ebp, eip, arg1, arg2, arg3, arg4); 
+		print_debuginfo(eip-1);
+		ebp = *((uint32_t*)(ebp));		
+		eip = *((uint32_t*)(ebp+4));
+	}
 }
 
diff -ruP lab3_org/kern/init/init.c lab3/kern/init/init.c
--- lab3_org/kern/init/init.c	2016-04-19 15:56:08.839058000 +0800
+++ lab3/kern/init/init.c	2016-04-18 13:54:45.268047000 +0800
@@ -93,11 +93,24 @@
 static void
 lab1_switch_to_user(void) {
     //LAB1 CHALLENGE 1 : TODO
+    asm volatile (
+    	"sub	$0x8, %%esp \n"
+    	"int	%0 \n"
+    	"movl	%%ebp,	%%esp \n"
+    	:
+    	:"i"(T_SWITCH_TOU)
+    );
 }
 
 static void
 lab1_switch_to_kernel(void) {
     //LAB1 CHALLENGE 1 :  TODO
+	asm volatile (
+		"int %0 \n"
+		"movl	%%ebp,	%%esp \n"
+		:
+		:"i"(T_SWITCH_TOK)
+	);
 }
 
 static void
diff -ruP lab3_org/kern/mm/default_pmm.c lab3/kern/mm/default_pmm.c
--- lab3_org/kern/mm/default_pmm.c	2016-04-19 15:56:08.823058000 +0800
+++ lab3/kern/mm/default_pmm.c	2016-04-17 20:07:38.525047000 +0800
@@ -59,6 +59,23 @@
 #define free_list (free_area.free_list)
 #define nr_free (free_area.nr_free)
 
+/////////////////////////////////////////////
+//display the free_list
+/*void disp_free_list(void)
+{
+	list_entry_t *le = &free_list;
+	struct Page *p = NULL;
+	cprintf("free_list:");
+	while((le = list_next(le)) != &free_list)
+	{	
+		p = le2page(le, page_link);
+		cprintf("%x ", (uint32_t)p);
+	}
+	cprintf("\n");
+}*/
+/////////////////////////////////////////////
+
+
 static void
 default_init(void) {
     list_init(&free_list);
@@ -101,7 +118,7 @@
             struct Page *p = page + n;
             p->property = page->property - n;
             list_add(&free_list, &(p->page_link));
-    }
+    	}
         nr_free -= n;
         ClearPageProperty(page);
     }
@@ -135,8 +152,27 @@
             list_del(&(p->page_link));
         }
     }
-    nr_free += n;
-    list_add(&free_list, &(base->page_link));
+   // nr_free += n;
+	if (nr_free)
+	{
+		nr_free += n;
+		le = &free_list;
+		do {
+			le = list_next(le);
+			p = le2page(le, page_link);
+			if (base > p)
+			{
+				list_add(le, &(base->page_link));
+				break;
+			}
+		} while(le != &free_list);
+	}
+	else
+	{
+		nr_free += n;
+	    list_add(&free_list, &(base->page_link));
+	}
+//    list_add(&free_list, &(base->page_link));
 }
 
 static size_t
@@ -151,7 +187,6 @@
     assert((p0 = alloc_page()) != NULL);
     assert((p1 = alloc_page()) != NULL);
     assert((p2 = alloc_page()) != NULL);
-
     assert(p0 != p1 && p0 != p2 && p1 != p2);
     assert(page_ref(p0) == 0 && page_ref(p1) == 0 && page_ref(p2) == 0);
 
@@ -211,6 +246,7 @@
     basic_check();
 
     struct Page *p0 = alloc_pages(5), *p1, *p2;
+	//disp_free_list();
     assert(p0 != NULL);
     assert(!PageProperty(p0));
 
@@ -223,19 +259,23 @@
     nr_free = 0;
 
     free_pages(p0 + 2, 3);
+	//disp_free_list();
     assert(alloc_pages(4) == NULL);
     assert(PageProperty(p0 + 2) && p0[2].property == 3);
     assert((p1 = alloc_pages(3)) != NULL);
+	//disp_free_list();
     assert(alloc_page() == NULL);
     assert(p0 + 2 == p1);
 
     p2 = p0 + 1;
     free_page(p0);
+	//disp_free_list();
     free_pages(p1, 3);
+	//disp_free_list();
     assert(PageProperty(p0) && p0->property == 1);
     assert(PageProperty(p1) && p1->property == 3);
-
     assert((p0 = alloc_page()) == p2 - 1);
+	///////////////////////////////
     free_page(p0);
     assert((p0 = alloc_pages(2)) == p2 + 1);
 
diff -ruP lab3_org/kern/mm/pmm.c lab3/kern/mm/pmm.c
--- lab3_org/kern/mm/pmm.c	2016-04-19 15:56:08.823058000 +0800
+++ lab3/kern/mm/pmm.c	2016-04-17 20:06:58.197047000 +0800
@@ -154,7 +154,6 @@
 alloc_pages(size_t n) {
     struct Page *page=NULL;
     bool intr_flag;
-    
     while (1)
     {
          local_intr_save(intr_flag);
@@ -381,18 +380,27 @@
      *   PTE_W           0x002                   // page table/directory entry flags bit : Writeable
      *   PTE_U           0x004                   // page table/directory entry flags bit : User can access
      */
-#if 0
-    pde_t *pdep = NULL;   // (1) find page directory entry
-    if (0) {              // (2) check if entry is not present
-                          // (3) check if creating is needed, then alloc page for page table
-                          // CAUTION: this page is used for page table, not for common data page
-                          // (4) set page reference
-        uintptr_t pa = 0; // (5) get linear address of page
-                          // (6) clear page content using memset
-                          // (7) set page directory entry's permission
+//#if 0
+    pde_t *pdep = NULL;  							 // (1) find page directory entry
+	pdep = &pgdir[PDX(la)];
+    if (!*pdep & PTE_P) {              		// (2) check if entry is not present
+		struct Page *pg;
+		if (create && (pg = alloc_page()) != NULL) {				 // (3) check if creating is needed, then alloc page for page table
+															    // CAUTION: this page is used for page table, not for common data page
+			set_page_ref(pg, 1); // (4) set page reference
+			uintptr_t pa = page2pa(pg);// (5) get linear address of page
+			memset(KADDR(pa), 0, PGSIZE);// (6) clear page content using memset
+			//cprintf("pa = %x####\n", pa&(~0xFFF)|PTE_P | PTE_W | PTE_U);
+			*pdep = ((pa & (~0xFFF)) | PTE_P | PTE_W | PTE_U);// (7) set page directory entry's permission
+			//cprintf("*pdep = %x\n",(uint32_t)*pdep);	
+		}
+		else
+		{
+			return NULL;
+		}
     }
-    return NULL;          // (8) return page table entry
-#endif
+    return &((pte_t*)KADDR(PDE_ADDR(*pdep)))[PTX(la)];// NULL;          // (8) return page table entry
+//#endif
 }
 
 //get_page - get related Page struct for linear address la using PDT pgdir
@@ -438,6 +446,17 @@
                                   //(6) flush tlb
     }
 #endif
+	if (*ptep & PTE_P && ptep != NULL)
+	{
+		struct Page *page = pte2page(*ptep);
+        page_ref_dec(page);
+		if (page->ref == 0)
+		{
+			free_page(page);
+			*ptep = 0;
+		}
+	}
+    tlb_invalidate(pgdir, la);
 }
 
 //page_remove - free an Page which is related linear address la and has an validated pte
@@ -464,6 +483,7 @@
         return -E_NO_MEM;
     }
     page_ref_inc(page);
+	//cprintf("ptep: %x\n", *ptep);
     if (*ptep & PTE_P) {
         struct Page *p = pte2page(*ptep);
         if (p == page) {
diff -ruP lab3_org/kern/mm/swap.c lab3/kern/mm/swap.c
--- lab3_org/kern/mm/swap.c	2016-04-19 15:56:08.823058000 +0800
+++ lab3/kern/mm/swap.c	2016-04-18 12:38:34.040047000 +0800
@@ -94,7 +94,7 @@
           }          
           //assert(!PageReserved(page));
 
-          //cprintf("SWAP: choose victim page 0x%08x\n", page);
+         // cprintf("SWAP: choose victim page 0x%08x\n", page);
           
           v=page->pra_vaddr; 
           pte_t *ptep = get_pte(mm->pgdir, v, 0);
@@ -123,7 +123,8 @@
      assert(result!=NULL);
 
      pte_t *ptep = get_pte(mm->pgdir, addr, 0);
-     // cprintf("SWAP: load ptep %x swap entry %d to vaddr 0x%08x, page %x, No %d\n", ptep, (*ptep)>>8, addr, result, (result-pages));
+      cprintf("SWAP: load ptep %x swap entry %d to vaddr 0x%08x, page %x, No %d\n", ptep, (*ptep)>>8, addr, result, (result-pages));
+
     
      int r;
      if ((r = swapfs_read((*ptep), result)) != 0)
@@ -211,7 +212,7 @@
      temp_ptep = get_pte(mm->pgdir, BEING_CHECK_VALID_VADDR, 1);
      assert(temp_ptep!= NULL);
      cprintf("setup Page Table vaddr 0~4MB OVER!\n");
-     
+    
      for (i=0;i<CHECK_VALID_PHY_PAGE_NUM;i++) {
           check_rp[i] = alloc_page();
           assert(check_rp[i] != NULL );
diff -ruP lab3_org/kern/mm/swap_fifo.c lab3/kern/mm/swap_fifo.c
--- lab3_org/kern/mm/swap_fifo.c	2016-04-19 15:56:08.823058000 +0800
+++ lab3/kern/mm/swap_fifo.c	2016-04-18 14:24:59.652047000 +0800
@@ -47,10 +47,22 @@
     list_entry_t *head=(list_entry_t*) mm->sm_priv;
     list_entry_t *entry=&(page->pra_page_link);
  
+	assert(entry != NULL);
+	assert(head != NULL);
     assert(entry != NULL && head != NULL);
     //record the page access situlation
     /*LAB3 EXERCISE 2: YOUR CODE*/ 
     //(1)link the most recent arrival page at the back of the pra_list_head qeueue.
+/*	if (swap_in)
+	{
+		list_entry_t *le = list_next(head);
+		while(le != head)
+		{
+			le = list_next(le);
+		}
+		list_add(le, entry);
+	}*/
+	list_add(head, entry);
     return 0;
 }
 /*
@@ -67,6 +79,24 @@
      /*LAB3 EXERCISE 2: YOUR CODE*/ 
      //(1)  unlink the  earliest arrival page in front of pra_list_head qeueue
      //(2)  set the addr of addr of this page to ptr_page
+/*	 struct Page *page = NULL;
+	 list_entry_t *le;
+	 //le = head->next;
+	 le = head->prev;
+	 assert(le != head);
+	// list_del(head->next);
+	 page = le2page(le, pra_page_link);
+	list_del(le);
+	assert(page != NULL);
+	 //ptr_page = &page;
+	 *ptr_page = page;
+*/
+	list_entry_t *le = head->prev;
+	assert(head != le);
+	struct Page *p = le2page(le, pra_page_link);
+	list_del(le);
+	assert(p != NULL);
+	*ptr_page = p;
      return 0;
 }
 
diff -ruP lab3_org/kern/mm/vmm.c lab3/kern/mm/vmm.c
--- lab3_org/kern/mm/vmm.c	2016-04-19 15:56:08.823058000 +0800
+++ lab3/kern/mm/vmm.c	2016-04-18 14:18:15.716047000 +0800
@@ -254,7 +254,6 @@
 
     uintptr_t addr = 0x100;
     assert(find_vma(mm, addr) == vma);
-
     int i, sum = 0;
     for (i = 0; i < 100; i ++) {
         *(char *)(addr + i) = i;
@@ -264,7 +263,6 @@
         sum -= *(char *)(addr + i);
     }
     assert(sum == 0);
-
     page_remove(pgdir, ROUNDDOWN(addr, PGSIZE));
     free_page(pde2page(pgdir[0]));
     pgdir[0] = 0;
@@ -306,7 +304,7 @@
     int ret = -E_INVAL;
     //try to find a vma which include addr
     struct vma_struct *vma = find_vma(mm, addr);
-
+	
     pgfault_num++;
     //If the addr is in the range of a mm's vma?
     if (vma == NULL || vma->vm_start > addr) {
@@ -364,6 +362,66 @@
     *   mm->pgdir : the PDT of these vma
     *
     */
+	if ((ptep = get_pte(mm->pgdir, addr, 1)) == NULL)
+	{
+		cprintf("get_pte in do_pgfault failed\n");
+		goto failed;
+	}
+	if (*ptep == 0)
+	{
+		if (pgdir_alloc_page(mm->pgdir, addr, perm) == NULL)
+		{
+			cprintf("pgdir_alloc_page in do_pgfault failed\n");
+			goto failed;
+		}
+	}
+	else
+	{
+		if (swap_init_ok)
+		{
+			struct Page *page = NULL;
+			if ((ret = swap_in(mm, addr, &page)) != 0)
+			{
+				cprintf("swap_in in do_pgfault failed\n");
+				goto failed;
+			}
+			page_insert(mm->pgdir, page, addr, perm);
+			swap_map_swappable(mm, addr, page, 1);
+			page->pra_vaddr = addr;
+
+		}
+		else
+		{
+			cprintf("no swap_init_ok but ptep is %x, failed\n", *ptep);
+			goto failed;
+		}
+	}
+/*	ptep = get_pte(mm->pgdir, addr, 1);
+	if (*ptep == 0) //page table null
+	{
+		pgdir_alloc_page(mm->pgdir, addr, perm);
+	}
+	else
+	{
+		if (swap_init_ok)
+		{
+			struct Page *page = NULL;
+			//swap_in(mm, addr, page);
+			if((ret = swap_in(mm, addr, &page)) != 0)
+			{
+				cprintf("Failed swap_in in do_pgfault\n");
+				goto failed;
+			}
+			page_insert(mm->pgdir, page, addr, perm);
+			swap_map_swappable(mm->pgdir, addr, page, 1);
+			page->pra_vaddr = addr;
+		}
+		else 
+		{
+			cprintf("no swap_init_ok but ptep is %x, failed\n", *ptep);
+			goto failed;
+		}
+	}*/
 #if 0
     /*LAB3 EXERCISE 1: YOUR CODE*/
     ptep = ???              //(1) try to find a pte, if pte's PT(Page Table) isn't existed, then create a PT.
diff -ruP lab3_org/kern/trap/trap.c lab3/kern/trap/trap.c
--- lab3_org/kern/trap/trap.c	2016-04-19 15:56:08.827058000 +0800
+++ lab3/kern/trap/trap.c	2016-04-15 14:03:58.054881515 +0800
@@ -33,6 +33,7 @@
     sizeof(idt) - 1, (uintptr_t)idt
 };
 
+extern uintptr_t __vectors[];
 /* idt_init - initialize IDT to each of the entry points in kern/trap/vectors.S */
 void
 idt_init(void) {
@@ -48,6 +49,14 @@
       *     You don't know the meaning of this instruction? just google it! and check the libs/x86.h to know more.
       *     Notice: the argument of lidt is idt_pd. try to find it!
       */
+    int i = 0;
+	for (i = 0; i < sizeof(idt)/sizeof(struct gatedesc); i ++) 
+	{
+		SETGATE(idt[i], 0, GD_KTEXT, __vectors[i], DPL_KERNEL); 
+	}
+	SETGATE(idt[T_SWITCH_TOK], 0, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);
+	lidt(&idt_pd);
+//	asm("lidt idt_pd");
 }
 
 static const char *
@@ -146,7 +155,7 @@
     cprintf("page fault at 0x%08x: %c/%c [%s].\n", rcr2(),
             (tf->tf_err & 4) ? 'U' : 'K',
             (tf->tf_err & 2) ? 'W' : 'R',
-            (tf->tf_err & 1) ? "protection fault" : "no page found");
+            (tf->tf_err & 1) ? "protection fault" : "no page found"); 
 }
 
 static int
@@ -162,6 +171,36 @@
 static volatile int in_swap_tick_event = 0;
 extern struct mm_struct *check_mm_struct;
 
+struct trapframe switchk2u, *switchu2k;
+
+void user2kernel(struct trapframe *tf)
+{
+	if (tf->tf_cs != KERNEL_CS)
+	{
+		tf->tf_cs = KERNEL_CS;
+		tf->tf_ds = tf->tf_es = KERNEL_DS;
+		tf->tf_eflags &= ~FL_IOPL_MASK;
+		switchu2k = (struct trapframe *)(tf->tf_esp - (sizeof(struct trapframe)-8));
+		memmove(switchu2k, tf, sizeof(struct trapframe)-8);
+		*((uint32_t*)tf-1) = (uint32_t)switchu2k;
+	}
+}
+
+void kernel2user(struct trapframe *tf)
+{
+    if (tf->tf_cs != USER_CS)
+    {
+    	switchk2u = *tf;
+    	switchk2u.tf_cs = USER_CS;
+    	switchk2u.tf_ds = switchk2u.tf_es = switchk2u.tf_ss = USER_DS;
+    	switchk2u.tf_esp = (uint32_t)tf + sizeof(struct trapframe)-8;
+
+		switchk2u.tf_eflags |= FL_IOPL_MASK;
+
+    	*((uint32_t *)tf -1) = (uint32_t)&switchk2u;
+    }
+}
+
 static void
 trap_dispatch(struct trapframe *tf) {
     char c;
@@ -186,6 +225,9 @@
          * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().
          * (3) Too Simple? Yes, I think so!
          */
+        ticks ++;
+        if (ticks % TICK_NUM == 0)
+       		print_ticks();
         break;
     case IRQ_OFFSET + IRQ_COM1:
         c = cons_getc();
@@ -194,11 +236,43 @@
     case IRQ_OFFSET + IRQ_KBD:
         c = cons_getc();
         cprintf("kbd [%03d] %c\n", c, c);
+        if (c == '0')
+        {
+        	user2kernel(tf);
+        }
+        if (c == '3')
+        {
+			kernel2user(tf);
+        }
+        print_trapframe(tf);
         break;
     //LAB1 CHALLENGE 1 : YOUR CODE you should modify below codes.
     case T_SWITCH_TOU:
+    	kernel2user(tf);
+/*    	if (tf->tf_cs != USER_CS)
+    	{
+    		switchk2u = *tf;
+    		switchk2u.tf_cs = USER_CS;
+    		switchk2u.tf_ds = switchk2u.tf_es = switchk2u.tf_ss = USER_DS;
+    		switchk2u.tf_esp = (uint32_t)tf + sizeof(struct trapframe)-8;
+
+    		switchk2u.tf_eflags |= FL_IOPL_MASK;
+
+    		*((uint32_t *)tf -1) = (uint32_t)&switchk2u;
+    	}*/
+    	break;
     case T_SWITCH_TOK:
-        panic("T_SWITCH_** ??\n");
+        //panic("T_SWITCH_** ??\n");
+        user2kernel(tf);
+/*        if (tf->tf_cs != KERNEL_CS)
+		{
+			tf->tf_cs = KERNEL_CS;
+			tf->tf_ds = tf->tf_es = KERNEL_DS;
+			tf->tf_eflags &= ~FL_IOPL_MASK;
+			switchu2k = (struct trapframe *)(tf->tf_esp - (sizeof(struct trapframe)-8));
+			memmove(switchu2k, tf, sizeof(struct trapframe)-8);
+			*((uint32_t*)tf-1) = (uint32_t)switchu2k;
+		}*/
         break;
     case IRQ_OFFSET + IRQ_IDE1:
     case IRQ_OFFSET + IRQ_IDE2:
diff -ruP lab3_org/tools/gdbinit.lab1 lab3/tools/gdbinit.lab1
--- lab3_org/tools/gdbinit.lab1	1970-01-01 08:00:00.000000000 +0800
+++ lab3/tools/gdbinit.lab1	2016-04-06 13:43:39.139975239 +0800
@@ -0,0 +1,7 @@
+file bin/kernel
+set architecture i8086
+target remote :1234
+break *0x7c00
+continue
+x /2i $pc
+set architecture i386
