--- kern/process/proc.c	2016-04-26 11:56:55.289039000 +0800
+++ kern/process/proc.c	2016-04-25 10:54:31.157058419 +0800
@@ -102,6 +102,18 @@
      *       uint32_t flags;                             // Process flag
      *       char name[PROC_NAME_LEN + 1];               // Process name
      */
+	 	proc->state = PROC_UNINIT;
+		proc->pid = -1;
+		proc->runs = 0;
+		proc->kstack = 0;
+		proc->need_resched = 0;
+		proc->parent = NULL;
+		proc->mm = NULL;
+	 	memset(&(proc->context), 0, sizeof(struct context));
+		proc->tf = NULL;
+		proc->cr3 = boot_cr3;
+		proc->flags = 0;
+		memset(proc->name, 0, PROC_NAME_LEN);
     }
     return proc;
 }
@@ -296,6 +308,30 @@
     //    5. insert proc_struct into hash_list && proc_list
     //    6. call wakeup_proc to make the new child process RUNNABLE
     //    7. set ret vaule using child proc's pid
+    if ((proc = alloc_proc()) == NULL) {
+        //panic("cannot alloc initproc.\n");
+		goto fork_out;
+    }
+	proc->parent =  current;
+	if (setup_kstack(proc) != 0) {
+	//	panic("cannot setup_kstack.\n");
+		goto bad_fork_cleanup_proc;
+	}
+	if (copy_mm(clone_flags, initproc) != 0) {
+		goto bad_fork_cleanup_kstack;
+	}
+	copy_thread(proc, stack, tf);
+	bool intr_flag;
+	local_intr_save(intr_flag);
+	{
+		proc->pid = get_pid();
+		hash_proc(proc);
+		list_add(&proc_list, &(proc->list_link));
+		nr_process ++;
+	}
+	local_intr_restore(intr_flag);
+	wakeup_proc(proc);
+	ret = proc->pid;
 fork_out:
     return ret;
 
